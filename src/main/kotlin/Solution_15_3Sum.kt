fun main() {
    val nums = intArrayOf(-1, 0, 1, 2, -1, -4)
    threeSum(nums)
}

/**
 * Объяснение алгоритма:
 *
 * Сортировка массива (nums.sort()) - ключевой шаг, который позволяет:
 *
 * Использовать технику двух указателей
 *
 * Легко пропускать дубликаты
 *
 * Находить тройки за O(n²)
 *
 * Основной цикл по i от 0 до nums.size - 3:
 *
 * Первое число тройки фиксировано как nums[i]
 *
 * Пропускаем дубликаты для первого числа
 *
 * Два указателя (left и right):
 *
 * left начинается с i + 1
 *
 * right начинается с конца массива
 *
 * Ищем пару чисел, которые в сумме с nums[i] дают 0
 *
 * Логика движения указателей:
 *
 * Если сумма равна 0 - добавляем тройку в результат и пропускаем дубликаты
 *
 * Если сумма меньше 0 - увеличиваем left (увеличиваем сумму)
 *
 * Если сумма больше 0 - уменьшаем right (уменьшаем сумму)
 *
 * Пропуск дубликатов:
 *
 * Для первого числа: пропускаем если nums[i] == nums[i-1]
 *
 * Для второго и третьего чисел: пропускаем дубликаты после нахождения тройки
 *
 * Сложность:
 * Временная сложность: O(n²), где n - размер массива
 *
 * Сортировка: O(n log n)
 *
 * Основной цикл: O(n²)
 *
 * Пространственная сложность: O(log n) для сортировки (если используется быстрая сортировка с O(log n) памяти) или O(n) для хранения результата
 */
fun threeSum(nums: IntArray): List<List<Int>> {
    // Сортируем массив
    nums.sort()
    val result = mutableListOf<List<Int>>()

    // Проходим по всем элементам, которые могут быть первым числом в тройке
    for (i in 0..nums.size - 2) {
        // Пропускаем дубликаты для первого числа
        if (i > 0 && nums[i] == nums[i - 1]) continue

        var left = i + 1
        var right = nums.size - 1

        while (left < right) {
            val sum = nums[i] + nums[left] + nums[right]

            when {
                sum == 0 -> {
                    // Нашли тройку
                    result.add(listOf(nums[i], nums[left], nums[right]))
                    // Пропускаем дубликаты для left и right
                    while (left < right && nums[left] == nums[left + 1]) left++
                    while (left < right && nums[right] == nums[right - 1]) right--

                    left++
                    right--
                }

                sum < 0 -> left++  // Сумма слишком мала, увеличиваем left
                sum > 0 -> right--  // Сумма слишком велика, уменьшаем right

            }
        }
    }
    return result
}