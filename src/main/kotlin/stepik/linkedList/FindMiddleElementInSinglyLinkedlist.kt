package stepik.linkedList

/**
 * Найдите срединный элемент в односвязном списке. Если список содержит четное количество элементов, верните второй элемент из двух средних.
 *
 * Формат входных данных:
 *
 * Первая строка содержит число n (1 ≤ n ≤ 10ˆ5) - количество элементов в списке. Вторая строка содержит n целых чисел (1 ≤ a_i ≤ 10ˆ9), разделенных пробелами - значения элементов списка.
 *
 * Формат выходных данных: Значение среднего элемента в списке.
 *
 * Sample Input:
 *
 * 5
 *
 * 1 2 3 4 5
 *
 * Sample Output:
 *
 * 3
 */

/**
 * Пояснение:
 *
 * Построение списка:
 *
 * Создаём головной узел списка из первого элемента входных данных.
 *
 * Последовательно добавляем остальные элементы, связывая узлы через next.
 *
 * Поиск среднего элемента:
 *
 * Инициализируем два указателя в начале списка (head).
 *
 * В цикле перемещаем slow на один узел, а fast — на два узла.
 *
 * Когда fast достигает конца списка (или выходит за него), slow останавливается на среднем элементе:
 *
 * Для нечётного n: slow на центральном элементе (например, для n=5 → элемент 3).
 *
 * Для чётного n: slow на втором из двух средних элементов (например, для n=4 → элемент 3).
 */

/**
 * Алгоритм решения:
 *
 * Инициализация указателей:
 *
 * slow (медленный указатель) перемещается на один узел за шаг.
 *
 * fast (быстрый указатель) перемещается на два узла за шаг.
 *
 * Проход по списку:
 *
 * Пока быстрый указатель (fast) не достигнет конца списка (или не выйдет за его пределы), перемещаем slow на один шаг, а fast — на два шага.
 *
 * Определение среднего элемента:
 *
 * Когда fast достигает конца списка, slow указывает на искомый средний элемент.
 *
 * Для чётного количества элементов (по условию) slow остановится на втором из двух средних элементов.
 */
fun main() {
    val n = readln()
    val values = readln().split(" ").map { it.toInt() }

//    val values = listOf(1, 2, 3, 4, 5, 6)

    // Создаем связный список
    val head = ListNode(values[0])
    var current = head
    for (i in 1 until values.size) {
        current.next = ListNode(values[i])
        current = current.next!!
    }

    // Определяем быстрый и медленный указатели
    var slow: ListNode? = head
    var fast: ListNode? = head

    // Ищем средний элемент
    // Когда быстрый указатель окажется в конце списка, медленный будет на среднем элементе
    while (fast?.next != null) {
        slow = slow?.next
        fast = fast.next?.next
    }

    println(slow?.value)
}